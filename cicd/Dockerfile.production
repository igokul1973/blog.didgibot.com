#
# Jenkins Kubernetes agent & CI stages for Angular frontend

# base: Node 22 + system tooling for lint/test/build/git commit/git push
FROM igk19/node-base:22 AS base

WORKDIR /workspace

# deps: install node dependencies (no app code yet)
FROM base AS deps
COPY package.json pnpm-lock.yaml* .npmrc* ./ 
RUN pnpm install --frozen-lockfile --ignore-scripts

# app: bring in source (used by lint/test/build targets)
FROM deps AS app
COPY . .

# lint stage: run lint
FROM app AS lint
RUN pnpm lint

# test stage: run coverage tests
FROM app AS test
RUN pnpm test:coverage && pnpm coverage:enforce

# Build stage: build Angular app (artifacts used by downstream image build).
# In essense it creates a `dist` folder with the built app.
FROM app AS build
RUN pnpm build

# Bump the version only if the lint and test stages pass.
# Uses semantic-release in dry-run mode to compute the next version from commits/tags,
# then writes that version into package.json for the subsequent commit stage.
FROM app AS bump_version
ENV HUSKY=0
ENV GH_TOKEN=dummy
ENV GITHUB_TOKEN=dummy
# Ensure tags are available even if origin is ssh-only in the workspace
# 1) Rewrite git@github.com URLs to https so fetch works in CI.
# 2) Fetch tags so semantic-release can compute the next version.
# 3) Run semantic-release in dry-run on the main branch (even if CI branch differs); fail if it cannot compute a version.
# 4) Parse computed version from semrel log; write package.json for the commit stage.
RUN git config --global url."https://github.com/".insteadOf "git@github.com:" && \
    git fetch --tags origin && \
    # semantic-release dry-run. Force main branch to compute version in non-main build contexts.
    pnpm release --ci --dry-run --no-verify --branches main 2>&1 | tee /tmp/semrel.log && \
    NEW_APP_VERSION=$(grep -m1 -oE "The next release version is [0-9]+\\.[0-9]+\\.[0-9]+" /tmp/semrel.log | awk '{print $6}') && \
    if [ -z "$NEW_APP_VERSION" ]; then \
        echo "‚ùå semantic-release did not compute a version; aborting."; \
        exit 1; \
    fi && \
    node -e "const fs=require('fs'); const pkg=require('./package.json'); pkg.version='$NEW_APP_VERSION'; fs.writeFileSync('package.json', JSON.stringify(pkg, null, 4)); console.log('package.json version set to', pkg.version);"

# Commit the codebase with the new version only if all the previous stages passed
FROM app AS commit_new_version

ARG GIT_USERNAME
ARG GIT_PASSWORD
ARG BRANCH_NAME

COPY --from=bump_version /workspace/package.json ./package.json
COPY --from=build /workspace/src/sitemap.xml ./src/sitemap.xml
RUN NEW_APP_VERSION=$(node -p "require('./package.json').version") && \
    git config --global --add safe.directory ./ && \
    git config --global user.name "Igor K." && \
    git config --global user.email "igk19@me.com" && \
    git add ./package.json ./src/sitemap.xml && \
    # Note, the `[version bump]` is needed at the end for the Jenkinsfile ignore the commit and not run any stages
    git commit -m "chore(release): Upgraded to a new application version - ${NEW_APP_VERSION} - [version bump]" && \
    git push https://${GIT_USERNAME}:${GIT_PASSWORD}@github.com/${GIT_USERNAME}/blog.didgibot.com.git HEAD:${BRANCH_NAME}

# image-production: base agent image (tools + workspace), default sleep
# FROM base AS image-production
# WORKDIR /workspace
# CMD ["sleep", "infinity"]