import groovy.transform.Field

// Jenkins CI/CD for Angular frontend (Node 22 agent pod + kaniko)
// Stages align with cicd/Dockerfile.production (lint, test, build) and final image build via kaniko.
// Two-run behavior: 
// 1. First run executes lint/test/build/image stages and bumps version and exits; 
// 2. Second run (post-push) executes without running any stages as it is triggered by a push to the Git
// remote repository of the version bump commit.
//
// Local pipeline state (booleans/strings) â€” only mirrored to env when Jenkins needs strings.
@Field Map state = [:]

pipeline {
    agent {
        kubernetes {
            yamlFile 'cicd/docker-agent-pod.yaml'
        }
    }
    environment {
        RESULTS_FILE_NAME = 'job-results.txt'
        IMAGE_TAG_NUMBER = "${BUILD_NUMBER}"
        DOCKER_IMAGE_NAME = "igk19/blog:${BUILD_NUMBER}"
        DOCKER_CONTAINER_NAME = "docker-${BUILD_NUMBER}"
        IMAGE_TAG_CHANGE_JOB_NAME = "change-image-name-in-blog-didgibot-com/${BRANCH_NAME}"
    }
    options { disableConcurrentBuilds() }

    stages {

        stage('Prepare') {
            steps {
                script {
                    check()
                }
            }
        }

        stage('Install dependencies') {
            when { expression { env.SHOULD_SKIP_CI?.trim() == 'false' } }
            steps {
                container('docker') {
                    sh """
                        docker build --network=host -f `pwd`/cicd/Dockerfile.production --target=deps -t ${env.DOCKER_CONTAINER_NAME} .
                    """
                }
            }
        }

        stage('Copy the app codebase') {
            when { expression { env.SHOULD_SKIP_CI?.trim() == 'false' } }
            steps {
                container('docker') {
                    sh """
                        docker build --network=host -f `pwd`/cicd/Dockerfile.production --target=app -t ${env.DOCKER_CONTAINER_NAME} .
                    """
                }
            }
        }

        stage('Continuous Integration') {
            when { expression { env.SHOULD_SKIP_CI?.trim() == 'false' } }
            parallel {
                stage('Lint') {
                    steps {
                        container('docker') {
                            sh """
                                docker build --network=host -f `pwd`/cicd/Dockerfile.production --target=lint -t ${env.DOCKER_CONTAINER_NAME}-lint .
                            """
                        }
                    }
                }

                stage('Test') {
                    steps {
                        container('docker') {
                            sh """
                                docker build --network=host -f `pwd`/cicd/Dockerfile.production --target=test -t ${env.DOCKER_CONTAINER_NAME}-test .
                                CID1="\$(docker create ${env.DOCKER_CONTAINER_NAME}-test)"
                                rm -rf ./coverage
                                docker cp "\$CID1:/workspace/coverage" ./coverage
                                # cleanup
                                docker rm -v "\$CID1"
                            """
                        }
                    }
                }

                stage('Build app') {
                    steps {
                        container ('docker') {
                            sh """
                                # build the test stage image (or whatever stage produces coverage)
                                docker build --network=host -f `pwd`/cicd/Dockerfile.production --target=build -t ${env.DOCKER_CONTAINER_NAME}-build .
                                # create a stopped container from that image
                                CID2="\$(docker create ${env.DOCKER_CONTAINER_NAME}-build)"
                                # copy 'dist' folder out of the container filesystem into Jenkins workspace
                                rm -rf ./dist
                                docker cp "\$CID2:/workspace/dist" ./dist
                                # cleanup
                                docker rm -v "\$CID2"
                            """
                        }
                    }
                }
            }
        }

        stage('Bump app version') {
            when { expression { env.SHOULD_SKIP_CI?.trim() == 'false' } }
            steps {
                container('docker') {
                    withCredentials([
                        sshUserPrivateKey(credentialsId: 'github_ssh_credentials', keyFileVariable: 'SSH_KEY'),
                        usernamePassword(credentialsId: 'bc934908-4192-4b50-bb32-5fad86943329', usernameVariable: 'USERNAME', passwordVariable: 'GH_TOKEN')
                    ]) {
                        script {
                            try {
                            sh """
                                docker build --network=host -f `pwd`/cicd/Dockerfile.production \
                                    --build-arg GH_TOKEN=${GH_TOKEN} \
                                    --build-arg BRANCH_NAME=${env.BRANCH_NAME} \
                                    --target=bump_version -t ${env.DOCKER_CONTAINER_NAME}-bump .
                            """
                            def nextVersion = sh(
                                returnStdout: true,
                                script: """
                                    docker run --rm ${env.DOCKER_CONTAINER_NAME}-bump \
                                    node -p "require('./package.json').version"
                                """
                            ).trim()
                            state.newAppVersion = nextVersion
                            env.NEW_APP_VERSION = nextVersion
                            if (env.NEW_APP_VERSION != env.CURRENT_APP_VERSION) {
                                state.appVersionWasBumped = true
                                env.APP_VERSION_WAS_BUMPED = 'true'
                            }
                            } catch (Exception e) {
                                state.bumpFailed = true
                                env.BUMP_FAILED = 'true'
                            }
                        }
                    }
                }
            }
        }

        // stage('Commit new app version') {
        //     when { expression { env.SHOULD_SKIP_CI?.trim() == 'false' } }
        //     steps {
        //         container ('docker') {
        //             withCredentials([
        //                 sshUserPrivateKey(credentialsId: 'github_ssh_credentials', keyFileVariable: 'SSH_KEY'),
        //                 usernamePassword(credentialsId: 'bc934908-4192-4b50-bb32-5fad86943329', usernameVariable: 'USERNAME', passwordVariable: 'GH_TOKEN')
        //             ]) {
        //                 sh '''
        //                     # it will commit the new version to the git remote repository
        //                     docker build --network=host -f cicd/Dockerfile.production \
        //                       --build-arg GIT_USERNAME=$USERNAME \
        //                       --build-arg GIT_PASSWORD=$GH_TOKEN \
        //                       --build-arg BRANCH_NAME=$BRANCH_NAME \
        //                       --target=commit_new_version -t $DOCKER_CONTAINER_NAME .
        //                 '''
        //             }
        //         }
        //     }
        // }

        stage('Image Build & Push') {
            when { expression { env.SHOULD_SKIP_CI?.trim() == 'false' && env.APP_VERSION_WAS_BUMPED == 'true' } }
            steps {
                container('kaniko') {
                        sh """
                            /kaniko/executor --dockerfile `pwd`/cicd/Dockerfile \
                                --context `pwd` \
                                --destination=${env.DOCKER_IMAGE_NAME}
                        """
                }
            }
        }

        stage('Change image in blog.didgibot.com deployment') {
            when { expression { env.SHOULD_SKIP_CI?.trim() == 'false' && env.APP_VERSION_WAS_BUMPED == 'true' } }
            steps {
                build job: env.IMAGE_TAG_CHANGE_JOB_NAME, parameters: [
                    string(name: 'IMAGE_TAG_NUMBER', value: env.IMAGE_TAG_NUMBER)
                ]
                // If the build job is successful, then the image tag number has been changed
                script {
                    state.imageTagNumberChanged = true
                    env.IMAGE_TAG_NUMBER_CHANGED = 'true'
                }
            }
        }
    }

    post {
        always {
            script {
                postProcess()
            }
        }
    }
}

void check() {
    state.buildResult = ''
    state.imageTagNumberChanged = false
    state.shouldSkipCi = false
    state.bumpFailed = false
    state.appVersionWasBumped = false
    def pkg = readJSON file: 'package.json'
    state.currentAppVersion = pkg.version?.toString()

    def result = sh(script: "git log -1 | grep '.*\\[skip ci\\].*'", returnStatus: true)
    if (result == 0) {
        println "The last commit is a [skip ci] so this run should skip CI stages."
        state.shouldSkipCi = true
    } else {
        println "The last commit is NOT a [skip ci] so this run should execute CI stages."
    }

    // Mirror state to env strings for when clauses / downstream use
    env.SHOULD_SKIP_CI = state.shouldSkipCi.toString()
    env.CURRENT_APP_VERSION = state.currentAppVersion
    env.BUMP_FAILED = state.bumpFailed.toString()
    env.APP_VERSION_WAS_BUMPED = state.appVersionWasBumped.toString()
    env.IMAGE_TAG_NUMBER_CHANGED = state.imageTagNumberChanged.toString()
}

void postProcess() {
    // Ensure we start from a clean message each run
    if (!state.buildResult) {
        state.buildResult = ''
    }
    // If the whole pipeline executes, i.e. it is a new commit with 
    // a feature, fix or another type of commit that changes the codebase
    if (state.shouldSkipCi) {
        def pkg = readJSON file: 'package.json'
        state.newAppVersion = pkg.version
        state.buildResult = "This job only indicates an application version bump commit to (${state.newAppVersion}) and its successful push to the Git remote repository.\nRun 'git pull' to update your local repository."
    } else {
        archiveArtifacts artifacts: 'coverage/**/*', allowEmptyArchive: false

        if (state.bumpFailed) {
            state.buildResult = 'This job was aborted: semantic-release could not compute the next application version (see bump_version stage logs). No commit or publish actions were performed.'
        } else {
            state.buildResult += state.appVersionWasBumped
                ? "Success! Bumped application version to ${state.newAppVersion}. Built and pushed docker app image ${env.DOCKER_IMAGE_NAME}."
                : "Success! The application version has NOT been bumped due to the lack of necessity."

            if (state.imageTagNumberChanged) {
                state.buildResult += "\nThe app image tag number (${env.IMAGE_TAG_NUMBER}) has been changed, which should trigger the ArgoCD application redeployment."
            } else if (state.appVersionWasBumped) {
                // This message indicates that the Jenkins job that pushes new tag number to the Git remote repository that redeploys current ArgoCD application failed
                state.buildResult += "\nBut the job to change the image tag number to (${env.IMAGE_TAG_NUMBER}) has NOT been successful."
                state.buildResult += "\nThe ArgoCD application redeployment will NOT be triggered."
                state.buildResult += "\nCheck that job's (${env.IMAGE_TAG_CHANGE_JOB_NAME}) logs for more details."
            } else {
                state.buildResult += "\nThe app image tag number (${env.IMAGE_TAG_NUMBER}) has NOT been changed."
            }
        }
    }

    if (state.buildResult != 'Pipeline was aborted due to some error. See the logs for more details.' && state.buildResult != 'This job was aborted: semantic-release could not compute the next application version (see bump_version stage logs). No commit or publish actions were performed.') {
        state.buildResult += "\nPipeline completed."
    }

    // Mirror final state to env for downstream visibility and artifacts
    env.BUILD_RESULT = state.buildResult
    env.NEW_APP_VERSION = state.newAppVersion?.toString() ?: env.NEW_APP_VERSION
    env.APP_VERSION_WAS_BUMPED = state.appVersionWasBumped.toString()
    env.IMAGE_TAG_NUMBER_CHANGED = state.imageTagNumberChanged.toString()
    env.BUMP_FAILED = state.bumpFailed.toString()
    env.SHOULD_SKIP_CI = state.shouldSkipCi.toString()

    writeFile file: env.RESULTS_FILE_NAME, text: "The job build result: ${env.BUILD_RESULT}"
    archiveArtifacts env.RESULTS_FILE_NAME
}